% The network generated by genNetworkMaskBF_CE.m always use the first
% channel to predict the mask. This function changes the network such that
% it uses all the 6 channels for mask prediction. For each channel, a
% speech and noise masks are predicted based on only the log spectrum of
% current channel. Then, the 6 sets of masks are pooled to get the final
% set of masks. 
%
function [layer, para] = ConvertMaskBF2pooling(layer, para)

ExtractDims_idx = ReturnLayerIdxByName(layer, 'ExtractDims');
if isempty(ExtractDims_idx)     % if this layer does not exist, the model is already using mask pooling, do nothing. 
    return;
end

STFT_layer_idx = ExtractDims_idx-1;
layer{ExtractDims_idx}.name = 'reshape';    % reshape speech into a tensor of nFreqBin x nFrame x nCh. The network will treat it as nCh utterances, and hence predict masks for each channel independently. 
layer{ExtractDims_idx}.sourceDims = para.topology.nFreqBin*para.topology.nCh;
layer{ExtractDims_idx}.targetDims = [para.topology.nFreqBin para.topology.nCh];
layer{ExtractDims_idx}.dim = [1 para.topology.nCh] * para.topology.nFreqBin;
if isfield(layer{ExtractDims_idx}, 'dimIndex')
    layer{ExtractDims_idx} = rmfield(layer{ExtractDims_idx}, 'dimIndex');
end
permuteLayer.name = 'permute';
permuteLayer.permute_order = [1 3 2];
permuteLayer.prev = -1;
permuteLayer.dim = [1 1]*layer{ExtractDims_idx}.dim(1);
permuteLayer.skipBP = 1;
layer = [layer(1:ExtractDims_idx) permuteLayer layer(ExtractDims_idx+1:end)];

lstm_idx =  ReturnLayerIdxByName(layer, 'LSTM');
pool_layer.name = lower(para.topology.poolingType);
pool_layer.prev = -1;
pool_layer.pool_idx = 3;     % pool over the third dimension, i.e. overal all channels
pool_layer.dim = [1 1] * para.topology.nFreqBin;

[~, split] = GetScmLayer(layer);
if ~split   % do not use split noise and speech mask prediction
    layer = [layer(1:lstm_idx+2) pool_layer layer(lstm_idx+3:end)];
    scm_layer = ReturnLayerIdxByName(layer, 'SpatialCovMask');
    layer{scm_layer}.prev = [-1 STFT_layer_idx-scm_layer];
else
    layer = [layer(1:lstm_idx+2) pool_layer layer(lstm_idx+3:lstm_idx+4) pool_layer layer(lstm_idx+5:end)];
    pool_idx = ReturnLayerIdxByName(layer, para.topology.poolingType);
    layer{pool_idx(1)+1}.prev = -4;
    layer{pool_idx(2)+1}.prev = [-4 -1 STFT_layer_idx-pool_idx(2)-1];
end
[layer, scm_idx, split] = HandleSTFTReference(layer, STFT_layer_idx, 1, para);

layer = FinishLayer(layer);
para.cost_func.layer_idx = para.cost_func.layer_idx - max(para.cost_func.layer_idx) + length(layer);

end
